/*!@preserve@license
 * 模块名称：j-orderify
 * 模块功能：返回一个能保证给定对象的属性按此后添加顺序排列的 proxy，即使键名是 symbol，或整数 string。从属于“简计划”。
   　　　　　Return a proxy for given object, which can guarantee own keys are in setting order, even if the key name is symbol or int string. Belong to "Plan J".
 * 模块版本：7.0.1
 * 许可条款：LGPL-3.0
 * 所属作者：龙腾道 <LongTengDao@LongTengDao.com> (www.LongTengDao.com)
 * 问题反馈：https://GitHub.com/LongTengDao/j-orderify/issues
 * 项目主页：https://GitHub.com/LongTengDao/j-orderify/
 */
const TypeError$1=TypeError,WeakMap$1=WeakMap,Proxy$1=Proxy,Object_assign=Object.assign,Object_create=Object.create,Object_is=Object.is,Object_defineProperty=Object.defineProperty,Object_getOwnPropertyDescriptor=Object.getOwnPropertyDescriptor,Object_defineProperties=Object.defineProperties,Object_fromEntries=Object.fromEntries,Object_freeze=Object.freeze,hasOwnProperty=Object.prototype.hasOwnProperty,Reflect_apply=Reflect.apply,Reflect_construct=Reflect.construct,Reflect_defineProperty=Reflect.defineProperty,Reflect_deleteProperty=Reflect.deleteProperty,Reflect_ownKeys=Reflect.ownKeys,undefined$1=void 0,NULL=Object.seal?Object.preventExtensions(Object.create(null)):null,version="7.0.1",toStringTag="undefined"==typeof Symbol?void 0:Symbol.toStringTag;var hasOwn=hasOwnProperty.bind?hasOwnProperty.call.bind(hasOwnProperty):function(e,t){return hasOwnProperty.call(e,t)};const Default=function(e,t){return function(e,t){if(t||(t=e,e=Object_create(NULL)),Object_assign)Object_assign(e,t);else for(var r in t)hasOwn(t,r)&&(e[r]=t[r]);if(e.default=e,toStringTag){var n=Object_create(NULL);n.value="Module",Object_defineProperty(e,toStringTag,n)}return"function"==typeof e&&e.prototype&&Object_freeze(e.prototype),Object_freeze(e)}(e,t)},Keeper=()=>[],hasOwnProperty_call=hasOwnProperty.call.bind(hasOwnProperty),newWeakMap=()=>{const e=new WeakMap$1;return e.has=e.has,e.get=e.get,e.set=e.set,e},target2keeper=newWeakMap(),proxy2target=newWeakMap(),target2proxy=newWeakMap(),ExternalDescriptor=e=>{const t=Object_create(NULL);return hasOwnProperty_call(e,"enumerable")&&(t.enumerable=e.enumerable),hasOwnProperty_call(e,"configurable")&&(t.configurable=e.configurable),hasOwnProperty_call(e,"value")&&(t.value=e.value),hasOwnProperty_call(e,"writable")&&(t.writable=e.writable),hasOwnProperty_call(e,"get")&&(t.get=e.get),hasOwnProperty_call(e,"set")&&(t.set=e.set),t},handlers=Object_assign(Object_create(NULL),{defineProperty:(e,t,r)=>{if(hasOwnProperty_call(e,t))return Reflect_defineProperty(e,t,Object_assign(Object_create(NULL),r));if(Reflect_defineProperty(e,t,Object_assign(Object_create(NULL),r))){const r=target2keeper.get(e);return r[r.length]=t,!0}return!1},deleteProperty:(e,t)=>{if(Reflect_deleteProperty(e,t)){const r=target2keeper.get(e),n=r.indexOf(t);return n<0||--r.copyWithin(n,n+1).length,!0}return!1},ownKeys:e=>target2keeper.get(e),construct:(e,t,r)=>orderify(Reflect_construct(e,t,r)),apply:(e,t,r)=>orderify(Reflect_apply(e,t,r))}),newProxy=(e,t)=>{target2keeper.set(e,t);const r=new Proxy$1(e,handlers);return proxy2target.set(r,e),r},isOrdered=e=>proxy2target.has(e),is=(e,t)=>Object_is(proxy2target.get(e)||e,proxy2target.get(t)||t),orderify=e=>{if(proxy2target.has(e))return e;let t=target2proxy.get(e);return t||(t=newProxy(e,Object_assign([],Reflect_ownKeys(e))),target2proxy.set(e,t),t)},{create}={create(e,...t){const r=[];if(t.length){const n=Object_assign(newProxy(Object_create(NULL),r),...t),{length:o}=r;let c=0;for(;c!==o;){const e=r[c++];n[e]=ExternalDescriptor(n[e])}return newProxy(Object_create(e,n),r)}return newProxy(Object_create(e),r)}},{defineProperties}={defineProperties(e,t,...r){const n=[];t=Object_assign(newProxy(Object_create(NULL),n),t,...r);const{length:o}=n;let c=0;for(;c!==o;){const e=n[c++];t[e]=ExternalDescriptor(t[e])}return Object_defineProperties(orderify(e),t)}},getOwnPropertyDescriptors=e=>{const t=Object_create(NULL),r=Object_assign([],Reflect_ownKeys(e)),{length:n}=r;let o=0;for(;o!==n;){const n=r[o++];t[n]=Object_assign(Object_create(NULL),Object_getOwnPropertyDescriptor(e,n))}return newProxy(t,r)},Null=function(){function e(){throw TypeError$1("Super constructor Null cannot be invoked with 'new'")}function t(){throw TypeError$1("Super constructor Null cannot be invoked without 'new'")}const r=e=>(delete e.prototype.constructor,Object_freeze(e.prototype),e);function n(o){return new.target?new.target===n?e():newProxy(this,[]):"function"==typeof o?r(o):t()}return n.prototype=null,Object_defineProperty(n,"name",Object_assign(Object_create(NULL),{value:"",configurable:!1})),Object_freeze(n),n}(),DEFAULT=Object_assign(class extends(null){writable(){}enumerable(){}configurable(){}}.prototype,{constructor:void 0,writable:!0,enumerable:!0,configurable:!0}),fromEntries=(e,t)=>{const r=Object_fromEntries(e),n=Object_assign([],Reflect_ownKeys(r));if(void 0===t)return newProxy(r,n);if(null===t)return newProxy(Object_assign(Object_create(t),r),n);const o=Object_create(NULL),{length:c}=n;let a=0;for(;a!==c;){const e=n[a++];(o[e]=Object_create(DEFAULT)).value=r[e]}return newProxy(Object_create(t,o),n)},_export=Default({version:"7.0.1",isOrdered,is,orderify,create,defineProperties,Null,fromEntries,getOwnPropertyDescriptors});export default _export;export{Null,create,defineProperties,fromEntries,getOwnPropertyDescriptors,is,isOrdered,orderify,version};
//# sourceMappingURL=j-orderify.min.js.map