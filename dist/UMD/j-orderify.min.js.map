{
	"version":
		3,
	"file":
		"j-orderify.min.js",
	"sourceRoot":
		"../../src/",
	"sources":
		["export.ts","version?text"],
	"sourcesContent":
		[
			"import Map from '.Map';\nimport * as Object from '.Object';\nimport Proxy from '.Proxy';\nimport * as Reflect from '.Reflect';\nimport Set from '.Set';\nimport TypeError from '.TypeError';\nimport WeakMap from '.WeakMap';\nimport undefined from '.undefined';\nimport isArray from '.Array.isArray';\n\nimport version from './version?text';\nexport { version };\n\ntype Target = object;\ntype Proxy = object;\ntype Key = string | symbol;\ntype Keeper = Set<Key>;\n\nconst Keeper = Set;\nconst target2keeper :WeakMap<Target, Keeper> = new WeakMap;\nconst proxy2target :WeakMap<Proxy, Target> = new WeakMap;\nconst target2proxy :WeakMap<Target, Proxy> = new WeakMap;\n\nconst setDescriptor = /*#__PURE__*/ function () {\n\tvar setDescriptor :PropertyDescriptor = Object.create(null);\n\tsetDescriptor.value = undefined;\n\tsetDescriptor.writable = true;\n\tsetDescriptor.enumerable = true;\n\tsetDescriptor.configurable = true;\n\treturn setDescriptor;\n}();\nconst handlers :object =\n\t/*#__PURE__*/\n\tObject.assign(Object.create(null), {\n\t\tapply (Function :{ (...args :any[]) :any }, thisArg :any, args :any[]) {\n\t\t\treturn orderify(Reflect.apply(Function, thisArg, args));\n\t\t},\n\t\tconstruct (Class :{ new (...args :any[]) :any }, args :any[], newTarget :any) {\n\t\t\treturn orderify(Reflect.construct(Class, args, newTarget));\n\t\t},\n\t\tdefineProperty (target :{}, key :Key, descriptor :PropertyDescriptor) :boolean {\n\t\t\tif ( Reflect.defineProperty(target, key, PartialDescriptor(descriptor)) ) {\n\t\t\t\ttarget2keeper.get(target)!.add(key);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\tdeleteProperty (target :{}, key :Key) :boolean {\n\t\t\tif ( Reflect.deleteProperty(target, key) ) {\n\t\t\t\ttarget2keeper.get(target)!.delete(key);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\townKeys (target :{}) :Key[] {\n\t\t\treturn [...target2keeper.get(target)!];\n\t\t},\n\t\tset (target :{}, key :Key, value :any, receiver :{}) :boolean {\n\t\t\tif ( key in target ) { return Reflect.set(target, key, value, receiver); }\n\t\t\tsetDescriptor.value = value;\n\t\t\tif ( Reflect.defineProperty(target, key, setDescriptor) ) {\n\t\t\t\ttarget2keeper.get(target)!.add(key);\n\t\t\t\tsetDescriptor.value = undefined;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsetDescriptor.value = undefined;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t});\n\nfunction newProxy<O extends object> (target :O, keeper :Keeper) :O {\n\ttarget2keeper.set(target, keeper);\n\tconst proxy :O = new Proxy(target, handlers);\n\tproxy2target.set(proxy, target);\n\treturn proxy;\n}\n\nexport const { isOrdered } = {\n\tisOrdered (object :object) :boolean {\n\t\treturn proxy2target.has(object);\n\t}\n};\nexport const { is } = {\n\tis (object1 :object, object2 :object) :boolean {\n\t\treturn Object.is(\n\t\t\tproxy2target.get(object1) || object1,\n\t\t\tproxy2target.get(object2) || object2,\n\t\t);\n\t}\n};\n\nexport const { orderify } = {\n\torderify<O extends object> (object :O) :O {\n\t\tif ( proxy2target.has(object) ) { return object; }\n\t\tlet proxy :O | undefined = target2proxy.get(object) as O | undefined;\n\t\tif ( proxy ) { return proxy; }\n\t\tproxy = newProxy(object, new Keeper(Reflect.ownKeys(object)));\n\t\ttarget2proxy.set(object, proxy);\n\t\treturn proxy;\n\t}\n};\nfunction getInternal (object :object) :{ target :any, keeper :Keeper, proxy :any } {\n\tconst target = proxy2target.get(object);\n\tif ( target ) { return { target, keeper: target2keeper.get(target)!, proxy: object }; }\n\tlet proxy = target2proxy.get(object);\n\tif ( proxy ) { return { target: object, keeper: target2keeper.get(object)!, proxy }; }\n\tconst keeper = new Keeper(Reflect.ownKeys(object));\n\ttarget2proxy.set(object, proxy = newProxy(object, keeper));\n\treturn { target: object, keeper, proxy };\n}\n\nfunction PartialDescriptor<D extends PropertyDescriptor> (source :D) :D {\n\tconst target :D = Object.create(null);\n\tif ( source.hasOwnProperty('value') ) {\n\t\ttarget.value = source.value;\n\t\tif ( source.hasOwnProperty('writable') ) { target.writable = source.writable; }\n\t}\n\telse if ( source.hasOwnProperty('writable') ) { target.writable = source.writable; }\n\telse if ( source.hasOwnProperty('get') ) {\n\t\ttarget.get = source.get;\n\t\tif ( source.hasOwnProperty('set') ) { target.set = source.set; }\n\t}\n\telse if ( source.hasOwnProperty('set') ) { target.set = source.set; }\n\tif ( source.hasOwnProperty('enumerable') ) { target.enumerable = source.enumerable; }\n\tif ( source.hasOwnProperty('configurable') ) { target.configurable = source.configurable; }\n\treturn target;\n}\nfunction InternalDescriptor<D extends PropertyDescriptor> (source :D) :D {\n\tconst target :D = Object.create(null);\n\tif ( source.hasOwnProperty('value') ) {\n\t\ttarget.value = source.value;\n\t\ttarget.writable = source.writable;\n\t}\n\telse {\n\t\ttarget.get = source.get;\n\t\ttarget.set = source.set;\n\t}\n\ttarget.enumerable = source.enumerable;\n\ttarget.configurable = source.configurable;\n\treturn target;\n}\nfunction ExternalDescriptor<D extends PropertyDescriptor> (source :D) :D {\n\tconst target :D = Object.create(null);\n\tif ( source.hasOwnProperty('value') ) { target.value = source.value; }\n\tif ( source.hasOwnProperty('writable') ) { target.writable = source.writable; }\n\tif ( source.hasOwnProperty('get') ) { target.get = source.get; }\n\tif ( source.hasOwnProperty('set') ) { target.set = source.set; }\n\tif ( source.hasOwnProperty('enumerable') ) { target.enumerable = source.enumerable; }\n\tif ( source.hasOwnProperty('configurable') ) { target.configurable = source.configurable; }\n\treturn target;\n}\n\ntype TypedPropertyDescriptorMap<O> = { [k in keyof O] :TypedPropertyDescriptor<O[k]> };\nexport const { create } = {\n\tcreate<O extends object, OO extends PropertyDescriptorMap = {}> (proto :null | O, descriptorMap? :OO) :( OO extends TypedPropertyDescriptorMap<infer O> ? O : {} ) & O {\n\t\tif ( descriptorMap===undefined ) { return newProxy(Object.create(proto), new Keeper); }\n\t\tconst target = Object.create(proto);\n\t\tconst keeper :Keeper = new Keeper;\n\t\tfor ( let lastIndex :number = arguments.length-1, index :number = 1; ; descriptorMap = arguments[++index] ) {\n\t\t\tconst keys = Reflect.ownKeys(descriptorMap!);\n\t\t\tfor ( let length :number = keys.length, index :number = 0; index<length; ++index ) {\n\t\t\t\tconst key = keys[index];\n\t\t\t\tObject.defineProperty(target, key, ExternalDescriptor(descriptorMap![key]));\n\t\t\t\tkeeper.add(key);\n\t\t\t}\n\t\t\tif ( index===lastIndex ) { return newProxy(target, keeper); }\n\t\t}\n\t}\n};\nexport const { defineProperties } = {\n\tdefineProperties<O extends object, OO extends PropertyDescriptorMap> (object :O, descriptorMap :OO) :( OO extends TypedPropertyDescriptorMap<infer O> ? O : never ) & O {\n\t\tconst { target, keeper, proxy } = getInternal(object);\n\t\tfor ( let lastIndex :number = arguments.length-1, index :number = 1; ; descriptorMap = arguments[++index] ) {\n\t\t\tconst keys = Reflect.ownKeys(descriptorMap);\n\t\t\tfor ( let length :number = keys.length, index :number = 0; index<length; ++index ) {\n\t\t\t\tconst key = keys[index];\n\t\t\t\tObject.defineProperty(target, key, ExternalDescriptor(descriptorMap[key]));\n\t\t\t\tkeeper.add(key);\n\t\t\t}\n\t\t\tif ( index===lastIndex ) { return proxy; }\n\t\t}\n\t}\n};\n\nexport const { getOwnPropertyDescriptors } = {\n\tgetOwnPropertyDescriptors<O extends object> (object :O) :{ [k in keyof O] :TypedPropertyDescriptor<O[k]> } {\n\t\tconst descriptors = Object.create(null);\n\t\tconst keeper :Keeper = new Keeper;\n\t\tconst keys = Reflect.ownKeys(object);\n\t\tfor ( let length :number = keys.length, index :number = 0; index<length; ++index ) {\n\t\t\tconst key = keys[index];\n\t\t\tdescriptors[key] = InternalDescriptor(Object.getOwnPropertyDescriptor(object, key)!);\n\t\t\tkeeper.add(key);\n\t\t}\n\t\treturn newProxy(descriptors, keeper);\n\t}\n};\n\nfunction keeperAddKeys (keeper :Keeper, object :{}) :void {\n\tconst keys :Key[] = Reflect.ownKeys(object);\n\tfor ( let length :number = keys.length, index :number = 0; index<length; ++index ) {\n\t\tkeeper.add(keys[index]);\n\t}\n}\nfunction NULL_from (source :{}[] | {}, define :boolean) :any {\n\tconst target = Object.create(null);\n\tconst keeper :Keeper = new Keeper;\n\tif ( define ) {\n\t\tif ( isArray(source) ) {\n\t\t\tfor ( let length :number = source.length, index :number = 0; index<length; ++index ) {\n\t\t\t\tconst descriptorMap = getOwnPropertyDescriptors(source[index]);\n\t\t\t\tObject.defineProperties(target, descriptorMap);\n\t\t\t\tkeeperAddKeys(keeper, descriptorMap);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tconst descriptorMap = getOwnPropertyDescriptors(source);\n\t\t\tObject.defineProperties(target, descriptorMap);\n\t\t\tkeeperAddKeys(keeper, descriptorMap);\n\t\t}\n\t}\n\telse {\n\t\tif ( isArray(source) ) {\n\t\t\tObject.assign(target, ...source);\n\t\t\tfor ( let length :number = source.length, index :number = 0; index<length; ++index ) {\n\t\t\t\tkeeperAddKeys(keeper, source[index]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tObject.assign(target, source);\n\t\t\tkeeperAddKeys(keeper, source);\n\t\t}\n\t}\n\treturn newProxy(target, keeper);\n}\nfunction throwConstructing () :never { throw TypeError(`NULL cannot be invoked with 'new'`); }\nexport const NULL :typeof import('./export.d').NULL =\n\t/*#__PURE__*/\n\tfunction (this :any) {\n\t\t'use strict';\n\t\tconst NULL :any = function <O extends {}> (this :object, source? :O[] | O, define? :boolean) :O {\n\t\t\treturn new.target\n\t\t\t\t? new.target===NULL\n\t\t\t\t\t? /*#__PURE__*/ throwConstructing()\n\t\t\t\t\t: /*#__PURE__*/ newProxy(this, new Keeper)\n\t\t\t\t: /*#__PURE__*/ NULL_from(source!, define!);\n\t\t};\n\t\tNULL.prototype = null;\n\t\t//delete NULL.name;\n\t\t//delete NULL.length;\n\t\tObject.freeze(NULL);\n\t\treturn NULL;\n\t}();\nexport type NULL<V> = import('./export.d').NULL<V>;\n\nconst PropertyKey :any =\n\t/*#__PURE__*/ new Proxy({}, { get<Key extends string | symbol> (target :{}, key :Key) :Key { return key; } });\nexport const { fromEntries } = {\n\tfromEntries<K extends string | symbol, V extends any, O extends object> (entries :Iterable<{ readonly 0 :K, readonly 1 :V }>, proto? :null | O) :{ [k in K] :V } & O {\n\t\tconst keeper :Keeper = new Keeper;\n\t\tconst map :Map<K, V> = new Map;\n\t\tfor ( let { 0: key, 1: value } of entries ) {\n\t\t\tkey = PropertyKey[key];\n\t\t\tkeeper.add(key);\n\t\t\tmap.set(key, value);\n\t\t}\n\t\tconst target = Object.fromEntries(map);\n\t\treturn newProxy(\n\t\t\tproto===undefined ? target :\n\t\t\t\tproto===null ? Object.assign(Object.create(null), target) :\n\t\t\t\t\tObject.create(target, getOwnPropertyDescriptors(proto)),\n\t\t\tkeeper\n\t\t);\n\t}\n};\n\nexport default (\n\t/*#__PURE__*/\n\tObject.freeze({\n\t\tversion,\n\t\tisOrdered,\n\t\tis,\n\t\torderify,\n\t\tcreate,\n\t\tdefineProperties,\n\t\tNULL,\n\t\tfromEntries,\n\t\tgetOwnPropertyDescriptors,\n\t\tget default () { return this; },\n\t})\n);\n",
			"export default '5.1.0';"
		],
	"names":
		["Keeper","Set","target2keeper","WeakMap","proxy2target","target2proxy","setDescriptor","Object.create","value","writable","enumerable","configurable","handlers","Object.assign","apply","Function","thisArg","args","orderify","Reflect.apply","construct","Class","newTarget","Reflect.construct","defineProperty","target","key","descriptor","Reflect.defineProperty","source","hasOwnProperty","get","set","PartialDescriptor","add","deleteProperty","Reflect.deleteProperty","delete","ownKeys","receiver","Reflect.set","newProxy","keeper","proxy","Proxy","isOrdered","object","has","is","object1","object2","Object.is","[object Object]","Reflect.ownKeys","InternalDescriptor","ExternalDescriptor","create","proto","descriptorMap","lastIndex","arguments","length","index","keys","Object.defineProperty","defineProperties","getInternal","getOwnPropertyDescriptors","descriptors","Object.getOwnPropertyDescriptor","keeperAddKeys","NULL_from","define","isArray","Object.defineProperties","throwConstructing","TypeError","NULL","this","prototype","Object.freeze","PropertyKey","fromEntries","entries","map","Map","0","1","Object.fromEntries","version","default"],
	"mappings":
		"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"
}