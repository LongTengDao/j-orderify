/*!
 * 模块名称：j-orderify
 * 模块功能：返回一个能保证给定对象的属性按此后添加顺序排列的 proxy，即使键名是 symbol，或整数 string。从属于“简计划”。
   　　　　　Return a proxy for given object, which can guarantee own keys are in setting order, even if the key name is symbol or int string. Belong to "Plan J".
 * 模块版本：7.0.0
 * 许可条款：LGPL-3.0
 * 所属作者：龙腾道 <LongTengDao@LongTengDao.com> (www.LongTengDao.com)
 * 问题反馈：https://GitHub.com/LongTengDao/j-orderify/issues
 * 项目主页：https://GitHub.com/LongTengDao/j-orderify/
 */
(function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e=e||self).Ordered=t()})(this,(function(){"use strict";const e=Object.assign,t=Object.create,r=Object.is,n=Object.defineProperty,o=Object.getOwnPropertyDescriptor,a=Object.fromEntries,l=Object.freeze,u=Reflect.apply,s=Reflect.construct,i=Reflect.defineProperty,c=Reflect.deleteProperty,f=Reflect.set,p=Reflect.ownKeys,w=Object.create?Object.preventExtensions(Object.create(null)):null,b=Object.prototype.hasOwnProperty,y="undefined"!=typeof Symbol?Symbol.toStringTag:void 0,g=Object.seal,d=Set,O=new WeakMap,h=new WeakMap,P=new WeakMap,v=e(t(w),{value:void 0,writable:!0,enumerable:!0,configurable:!0}),m=e(t(w),{apply:(e,t,r)=>k(u(e,t,r)),construct:(e,t,r)=>k(s(e,t,r)),defineProperty:(e,r,n)=>!!i(e,r,function(e){const r=t(w);e.hasOwnProperty("value")?(r.value=e.value,e.hasOwnProperty("writable")&&(r.writable=e.writable)):e.hasOwnProperty("writable")?r.writable=e.writable:e.hasOwnProperty("get")?(r.get=e.get,e.hasOwnProperty("set")&&(r.set=e.set)):e.hasOwnProperty("set")&&(r.set=e.set);e.hasOwnProperty("enumerable")&&(r.enumerable=e.enumerable);e.hasOwnProperty("configurable")&&(r.configurable=e.configurable);return r}(n))&&(O.get(e).add(r),!0),deleteProperty:(e,t)=>!!c(e,t)&&(O.get(e).delete(t),!0),ownKeys:e=>[...O.get(e)],set:(e,t,r,n)=>t in e?f(e,t,r,n):(v.value=r,i(e,t,v)?(O.get(e).add(t),v.value=void 0,!0):(v.value=void 0,!1))});function j(e,t){O.set(e,t);const r=new Proxy(e,m);return h.set(r,e),r}const k=e=>{if(h.has(e))return e;let t=P.get(e);return t||(t=j(e,new d(p(e))),P.set(e,t),t)};function x(e){const r=t(w);return e.hasOwnProperty("value")?(r.value=e.value,r.writable=e.writable):(r.get=e.get,r.set=e.set),r.enumerable=e.enumerable,r.configurable=e.configurable,r}function R(e){const r=t(w);return e.hasOwnProperty("value")&&(r.value=e.value),e.hasOwnProperty("writable")&&(r.writable=e.writable),e.hasOwnProperty("get")&&(r.get=e.get),e.hasOwnProperty("set")&&(r.set=e.set),e.hasOwnProperty("enumerable")&&(r.enumerable=e.enumerable),e.hasOwnProperty("configurable")&&(r.configurable=e.configurable),r}const{create:S}={create(r,n){if(arguments.length<2)return j(t(r),new d);const o=new d;n=arguments[0]=j(t(w),o),u(e,null,arguments);const a=t(r,n);for(const e of o)n[e]=R(n[e]);return j(a,o)}},{defineProperties:E}={defineProperties(e,t){const{target:r,keeper:o,proxy:a}=function(e){const t=h.get(e);if(t)return{target:t,keeper:O.get(t),proxy:e};let r=P.get(e);if(r)return{target:e,keeper:O.get(e),proxy:r};const n=new d(p(e));return P.set(e,r=j(e,n)),{target:e,keeper:n,proxy:r}}(e);for(let l=arguments.length-1,u=1;;t=arguments[++u]){const e=p(t);for(let a=e.length,l=0;l<a;++l){const a=e[l];n(r,a,R(t[a])),o.add(a)}if(u===l)return a}}},M=e=>{const r=t(w),n=new d,a=p(e);for(let t=a.length,l=0;l<t;++l){const t=a[l];r[t]=x(o(e,t)),n.add(t)}return j(r,n)},N=function(){function r(){throw TypeError("Super constructor Null cannot be invoked with 'new'")}function o(){throw TypeError("Super constructor Null cannot be invoked without 'new'")}function a(){return new.target?new.target===a?r():j(this,new d):o()}return a.prototype=null,n(a,"name",e(t(w),{value:""})),l(a),a}(),T=new Proxy({},{get:(e,t)=>t});return function(r,o){return function(r,o){if(o||(o=r,r=t(w)),e)e(r,o);else for(var a in o)b.call(o,a)&&(r[a]=o[a]);if(r.default=r,"function"==typeof r&&r.prototype&&g(r.prototype),y){var u=t(w);u.value="Module",n(r,y,u)}return l(r)}(r,o)}({version:"7.0.0",isOrdered:e=>h.has(e),is:(e,t)=>r(h.get(e)||e,h.get(t)||t),orderify:k,create:S,defineProperties:E,Null:N,fromEntries:(r,n)=>{const o=new d,l=new Map;for(let{0:e,1:t}of r)e=T[e],o.add(e),l.set(e,t);const u=a(l);return j(void 0===n?u:null===n?e(t(n),u):t(u,M(n)),o)},getOwnPropertyDescriptors:M})}));
//# sourceMappingURL=j-orderify.min.js.map