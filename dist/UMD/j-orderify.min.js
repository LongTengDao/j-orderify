/*!
 * 模块名称：j-orderify
 * 模块功能：返回一个能保证给定对象的属性按此后添加顺序排列的 proxy，即使键名是 symbol，或整数 string。从属于“简计划”。
   　　　　　Return a proxy for given object, which can guarantee own keys are in setting order, even if the key name is symbol or int string. Belong to "Plan J".
 * 模块版本：5.1.0
 * 许可条款：LGPL-3.0
 * 所属作者：龙腾道 <LongTengDao@LongTengDao.com> (www.LongTengDao.com)
 * 问题反馈：https://GitHub.com/LongTengDao/j-orderify/issues
 * 项目主页：https://GitHub.com/LongTengDao/j-orderify/
 */
(function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e=e||self).Ordered=t()})(this,function(){"use strict";const e=Object.assign,t=Object.create,r=Object.defineProperties,n=Object.defineProperty,o=Object.freeze,s=Object.fromEntries,l=Object.getOwnPropertyDescriptor,a=Object.is,i=Reflect.apply,u=Reflect.construct,c=Reflect.defineProperty,f=Reflect.deleteProperty,p=Reflect.ownKeys,w=Reflect.set,d=Array.isArray,g=Set,y=new WeakMap,b=new WeakMap,O=new WeakMap,h=function(){var e=t(null);return e.value=void 0,e.writable=!0,e.enumerable=!0,e.configurable=!0,e}(),P=e(t(null),{apply:(e,t,r)=>k(i(e,t,r)),construct:(e,t,r)=>k(u(e,t,r)),defineProperty:(e,r,n)=>!!c(e,r,function(e){const r=t(null);e.hasOwnProperty("value")?(r.value=e.value,e.hasOwnProperty("writable")&&(r.writable=e.writable)):e.hasOwnProperty("writable")?r.writable=e.writable:e.hasOwnProperty("get")?(r.get=e.get,e.hasOwnProperty("set")&&(r.set=e.set)):e.hasOwnProperty("set")&&(r.set=e.set);e.hasOwnProperty("enumerable")&&(r.enumerable=e.enumerable);e.hasOwnProperty("configurable")&&(r.configurable=e.configurable);return r}(n))&&(y.get(e).add(r),!0),deleteProperty:(e,t)=>!!f(e,t)&&(y.get(e).delete(t),!0),ownKeys:e=>[...y.get(e)],set:(e,t,r,n)=>t in e?w(e,t,r,n):(h.value=r,c(e,t,h)?(y.get(e).add(t),h.value=void 0,!0):(h.value=void 0,!1))});function v(e,t){y.set(e,t);const r=new Proxy(e,P);return b.set(r,e),r}const{isOrdered:m}={isOrdered:e=>b.has(e)},{is:j}={is:(e,t)=>a(b.get(e)||e,b.get(t)||t)},{orderify:k}={orderify(e){if(b.has(e))return e;let t=O.get(e);return t||(t=v(e,new g(p(e))),O.set(e,t),t)}};function x(e){const r=t(null);return e.hasOwnProperty("value")?(r.value=e.value,r.writable=e.writable):(r.get=e.get,r.set=e.set),r.enumerable=e.enumerable,r.configurable=e.configurable,r}function R(e){const r=t(null);return e.hasOwnProperty("value")&&(r.value=e.value),e.hasOwnProperty("writable")&&(r.writable=e.writable),e.hasOwnProperty("get")&&(r.get=e.get),e.hasOwnProperty("set")&&(r.set=e.set),e.hasOwnProperty("enumerable")&&(r.enumerable=e.enumerable),e.hasOwnProperty("configurable")&&(r.configurable=e.configurable),r}const{create:E}={create(e,r){if(void 0===r)return v(t(e),new g);const o=t(e),s=new g;for(let t=arguments.length-1,l=1;;r=arguments[++l]){const e=p(r);for(let t=e.length,l=0;l<t;++l){const t=e[l];n(o,t,R(r[t])),s.add(t)}if(l===t)return v(o,s)}}},{defineProperties:D}={defineProperties(e,t){const{target:r,keeper:o,proxy:s}=function(e){const t=b.get(e);if(t)return{target:t,keeper:y.get(t),proxy:e};let r=O.get(e);if(r)return{target:e,keeper:y.get(e),proxy:r};const n=new g(p(e));return O.set(e,r=v(e,n)),{target:e,keeper:n,proxy:r}}(e);for(let l=arguments.length-1,a=1;;t=arguments[++a]){const e=p(t);for(let s=e.length,l=0;l<s;++l){const s=e[l];n(r,s,R(t[s])),o.add(s)}if(a===l)return s}}},{getOwnPropertyDescriptors:L}={getOwnPropertyDescriptors(e){const r=t(null),n=new g,o=p(e);for(let t=o.length,s=0;s<t;++s){const t=o[s];r[t]=x(l(e,t)),n.add(t)}return v(r,n)}};function M(e,t){const r=p(t);for(let n=r.length,o=0;o<n;++o)e.add(r[o])}function W(n,o){const s=t(null),l=new g;if(o)if(d(n))for(let e=n.length,t=0;t<e;++t){const e=L(n[t]);r(s,e),M(l,e)}else{const e=L(n);r(s,e),M(l,e)}else if(d(n)){e(s,...n);for(let e=n.length,t=0;t<e;++t)M(l,n[t])}else e(s,n),M(l,n);return v(s,l)}function A(){throw TypeError("NULL cannot be invoked with 'new'")}const K=function(){const e=function(t,r){return new.target?new.target===e?A():v(this,new g):W(t,r)};return e.prototype=null,o(e),e}(),N=new Proxy({},{get:(e,t)=>t}),{fromEntries:U}={fromEntries(r,n){const o=new g,l=new Map;for(let{0:e,1:t}of r)o.add(e=N[e]),l.set(e,t);const a=s(l);return v(void 0===n?a:null===n?e(t(null),a):t(a,L(n)),o)}};return o({version:"5.1.0",isOrdered:m,is:j,orderify:k,create:E,defineProperties:D,NULL:K,fromEntries:U,getOwnPropertyDescriptors:L,get default(){return this}})});
//# sourceMappingURL=j-orderify.min.js.map